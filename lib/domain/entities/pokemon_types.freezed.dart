// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'pokemon_types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

PokemonTypes _$PokemonTypesFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'normal':
      return _Normal.fromJson(json);
    case 'fire':
      return _Fire.fromJson(json);
    case 'water':
      return _Water.fromJson(json);
    case 'grass':
      return _Grass.fromJson(json);
    case 'electric':
      return _Electric.fromJson(json);
    case 'ice':
      return _Ice.fromJson(json);
    case 'fighting':
      return _Fighting.fromJson(json);
    case 'poison':
      return _Poison.fromJson(json);
    case 'ground':
      return _Ground.fromJson(json);
    case 'flying':
      return _Flying.fromJson(json);
    case 'psychic':
      return _Psychic.fromJson(json);
    case 'bug':
      return _Bug.fromJson(json);
    case 'rock':
      return _Rock.fromJson(json);
    case 'ghost':
      return _Ghost.fromJson(json);
    case 'dark':
      return _Dark.fromJson(json);
    case 'dragon':
      return _Dragon.fromJson(json);
    case 'steel':
      return _Steel.fromJson(json);
    case 'fairy':
      return _Fairy.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'PokemonTypes',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$PokemonTypes {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PokemonTypesCopyWith<$Res> {
  factory $PokemonTypesCopyWith(
          PokemonTypes value, $Res Function(PokemonTypes) then) =
      _$PokemonTypesCopyWithImpl<$Res>;
}

/// @nodoc
class _$PokemonTypesCopyWithImpl<$Res> implements $PokemonTypesCopyWith<$Res> {
  _$PokemonTypesCopyWithImpl(this._value, this._then);

  final PokemonTypes _value;
  // ignore: unused_field
  final $Res Function(PokemonTypes) _then;
}

/// @nodoc
abstract class _$$_NormalCopyWith<$Res> {
  factory _$$_NormalCopyWith(_$_Normal value, $Res Function(_$_Normal) then) =
      __$$_NormalCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NormalCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_NormalCopyWith<$Res> {
  __$$_NormalCopyWithImpl(_$_Normal _value, $Res Function(_$_Normal) _then)
      : super(_value, (v) => _then(v as _$_Normal));

  @override
  _$_Normal get _value => super._value as _$_Normal;
}

/// @nodoc
@JsonSerializable()
class _$_Normal extends _Normal {
  const _$_Normal({final String? $type})
      : $type = $type ?? 'normal',
        super._();

  factory _$_Normal.fromJson(Map<String, dynamic> json) =>
      _$$_NormalFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Normal);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return normal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return normal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (normal != null) {
      return normal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return normal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return normal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (normal != null) {
      return normal(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_NormalToJson(
      this,
    );
  }
}

abstract class _Normal extends PokemonTypes {
  const factory _Normal() = _$_Normal;
  const _Normal._() : super._();

  factory _Normal.fromJson(Map<String, dynamic> json) = _$_Normal.fromJson;
}

/// @nodoc
abstract class _$$_FireCopyWith<$Res> {
  factory _$$_FireCopyWith(_$_Fire value, $Res Function(_$_Fire) then) =
      __$$_FireCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FireCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_FireCopyWith<$Res> {
  __$$_FireCopyWithImpl(_$_Fire _value, $Res Function(_$_Fire) _then)
      : super(_value, (v) => _then(v as _$_Fire));

  @override
  _$_Fire get _value => super._value as _$_Fire;
}

/// @nodoc
@JsonSerializable()
class _$_Fire extends _Fire {
  const _$_Fire({final String? $type})
      : $type = $type ?? 'fire',
        super._();

  factory _$_Fire.fromJson(Map<String, dynamic> json) => _$$_FireFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Fire);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return fire();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return fire?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (fire != null) {
      return fire();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return fire(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return fire?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (fire != null) {
      return fire(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FireToJson(
      this,
    );
  }
}

abstract class _Fire extends PokemonTypes {
  const factory _Fire() = _$_Fire;
  const _Fire._() : super._();

  factory _Fire.fromJson(Map<String, dynamic> json) = _$_Fire.fromJson;
}

/// @nodoc
abstract class _$$_WaterCopyWith<$Res> {
  factory _$$_WaterCopyWith(_$_Water value, $Res Function(_$_Water) then) =
      __$$_WaterCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_WaterCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_WaterCopyWith<$Res> {
  __$$_WaterCopyWithImpl(_$_Water _value, $Res Function(_$_Water) _then)
      : super(_value, (v) => _then(v as _$_Water));

  @override
  _$_Water get _value => super._value as _$_Water;
}

/// @nodoc
@JsonSerializable()
class _$_Water extends _Water {
  const _$_Water({final String? $type})
      : $type = $type ?? 'water',
        super._();

  factory _$_Water.fromJson(Map<String, dynamic> json) =>
      _$$_WaterFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Water);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return water();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return water?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (water != null) {
      return water();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return water(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return water?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (water != null) {
      return water(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_WaterToJson(
      this,
    );
  }
}

abstract class _Water extends PokemonTypes {
  const factory _Water() = _$_Water;
  const _Water._() : super._();

  factory _Water.fromJson(Map<String, dynamic> json) = _$_Water.fromJson;
}

/// @nodoc
abstract class _$$_GrassCopyWith<$Res> {
  factory _$$_GrassCopyWith(_$_Grass value, $Res Function(_$_Grass) then) =
      __$$_GrassCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GrassCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_GrassCopyWith<$Res> {
  __$$_GrassCopyWithImpl(_$_Grass _value, $Res Function(_$_Grass) _then)
      : super(_value, (v) => _then(v as _$_Grass));

  @override
  _$_Grass get _value => super._value as _$_Grass;
}

/// @nodoc
@JsonSerializable()
class _$_Grass extends _Grass {
  const _$_Grass({final String? $type})
      : $type = $type ?? 'grass',
        super._();

  factory _$_Grass.fromJson(Map<String, dynamic> json) =>
      _$$_GrassFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Grass);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return grass();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return grass?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (grass != null) {
      return grass();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return grass(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return grass?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (grass != null) {
      return grass(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_GrassToJson(
      this,
    );
  }
}

abstract class _Grass extends PokemonTypes {
  const factory _Grass() = _$_Grass;
  const _Grass._() : super._();

  factory _Grass.fromJson(Map<String, dynamic> json) = _$_Grass.fromJson;
}

/// @nodoc
abstract class _$$_ElectricCopyWith<$Res> {
  factory _$$_ElectricCopyWith(
          _$_Electric value, $Res Function(_$_Electric) then) =
      __$$_ElectricCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ElectricCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_ElectricCopyWith<$Res> {
  __$$_ElectricCopyWithImpl(
      _$_Electric _value, $Res Function(_$_Electric) _then)
      : super(_value, (v) => _then(v as _$_Electric));

  @override
  _$_Electric get _value => super._value as _$_Electric;
}

/// @nodoc
@JsonSerializable()
class _$_Electric extends _Electric {
  const _$_Electric({final String? $type})
      : $type = $type ?? 'electric',
        super._();

  factory _$_Electric.fromJson(Map<String, dynamic> json) =>
      _$$_ElectricFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Electric);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return electric();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return electric?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (electric != null) {
      return electric();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return electric(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return electric?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (electric != null) {
      return electric(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_ElectricToJson(
      this,
    );
  }
}

abstract class _Electric extends PokemonTypes {
  const factory _Electric() = _$_Electric;
  const _Electric._() : super._();

  factory _Electric.fromJson(Map<String, dynamic> json) = _$_Electric.fromJson;
}

/// @nodoc
abstract class _$$_IceCopyWith<$Res> {
  factory _$$_IceCopyWith(_$_Ice value, $Res Function(_$_Ice) then) =
      __$$_IceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_IceCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_IceCopyWith<$Res> {
  __$$_IceCopyWithImpl(_$_Ice _value, $Res Function(_$_Ice) _then)
      : super(_value, (v) => _then(v as _$_Ice));

  @override
  _$_Ice get _value => super._value as _$_Ice;
}

/// @nodoc
@JsonSerializable()
class _$_Ice extends _Ice {
  const _$_Ice({final String? $type})
      : $type = $type ?? 'ice',
        super._();

  factory _$_Ice.fromJson(Map<String, dynamic> json) => _$$_IceFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Ice);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return ice();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return ice?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (ice != null) {
      return ice();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return ice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return ice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (ice != null) {
      return ice(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_IceToJson(
      this,
    );
  }
}

abstract class _Ice extends PokemonTypes {
  const factory _Ice() = _$_Ice;
  const _Ice._() : super._();

  factory _Ice.fromJson(Map<String, dynamic> json) = _$_Ice.fromJson;
}

/// @nodoc
abstract class _$$_FightingCopyWith<$Res> {
  factory _$$_FightingCopyWith(
          _$_Fighting value, $Res Function(_$_Fighting) then) =
      __$$_FightingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FightingCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_FightingCopyWith<$Res> {
  __$$_FightingCopyWithImpl(
      _$_Fighting _value, $Res Function(_$_Fighting) _then)
      : super(_value, (v) => _then(v as _$_Fighting));

  @override
  _$_Fighting get _value => super._value as _$_Fighting;
}

/// @nodoc
@JsonSerializable()
class _$_Fighting extends _Fighting {
  const _$_Fighting({final String? $type})
      : $type = $type ?? 'fighting',
        super._();

  factory _$_Fighting.fromJson(Map<String, dynamic> json) =>
      _$$_FightingFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Fighting);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return fighting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return fighting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (fighting != null) {
      return fighting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return fighting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return fighting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (fighting != null) {
      return fighting(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FightingToJson(
      this,
    );
  }
}

abstract class _Fighting extends PokemonTypes {
  const factory _Fighting() = _$_Fighting;
  const _Fighting._() : super._();

  factory _Fighting.fromJson(Map<String, dynamic> json) = _$_Fighting.fromJson;
}

/// @nodoc
abstract class _$$_PoisonCopyWith<$Res> {
  factory _$$_PoisonCopyWith(_$_Poison value, $Res Function(_$_Poison) then) =
      __$$_PoisonCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PoisonCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_PoisonCopyWith<$Res> {
  __$$_PoisonCopyWithImpl(_$_Poison _value, $Res Function(_$_Poison) _then)
      : super(_value, (v) => _then(v as _$_Poison));

  @override
  _$_Poison get _value => super._value as _$_Poison;
}

/// @nodoc
@JsonSerializable()
class _$_Poison extends _Poison {
  const _$_Poison({final String? $type})
      : $type = $type ?? 'poison',
        super._();

  factory _$_Poison.fromJson(Map<String, dynamic> json) =>
      _$$_PoisonFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Poison);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return poison();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return poison?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (poison != null) {
      return poison();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return poison(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return poison?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (poison != null) {
      return poison(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_PoisonToJson(
      this,
    );
  }
}

abstract class _Poison extends PokemonTypes {
  const factory _Poison() = _$_Poison;
  const _Poison._() : super._();

  factory _Poison.fromJson(Map<String, dynamic> json) = _$_Poison.fromJson;
}

/// @nodoc
abstract class _$$_GroundCopyWith<$Res> {
  factory _$$_GroundCopyWith(_$_Ground value, $Res Function(_$_Ground) then) =
      __$$_GroundCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GroundCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_GroundCopyWith<$Res> {
  __$$_GroundCopyWithImpl(_$_Ground _value, $Res Function(_$_Ground) _then)
      : super(_value, (v) => _then(v as _$_Ground));

  @override
  _$_Ground get _value => super._value as _$_Ground;
}

/// @nodoc
@JsonSerializable()
class _$_Ground extends _Ground {
  const _$_Ground({final String? $type})
      : $type = $type ?? 'ground',
        super._();

  factory _$_Ground.fromJson(Map<String, dynamic> json) =>
      _$$_GroundFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Ground);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return ground();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return ground?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (ground != null) {
      return ground();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return ground(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return ground?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (ground != null) {
      return ground(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_GroundToJson(
      this,
    );
  }
}

abstract class _Ground extends PokemonTypes {
  const factory _Ground() = _$_Ground;
  const _Ground._() : super._();

  factory _Ground.fromJson(Map<String, dynamic> json) = _$_Ground.fromJson;
}

/// @nodoc
abstract class _$$_FlyingCopyWith<$Res> {
  factory _$$_FlyingCopyWith(_$_Flying value, $Res Function(_$_Flying) then) =
      __$$_FlyingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FlyingCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_FlyingCopyWith<$Res> {
  __$$_FlyingCopyWithImpl(_$_Flying _value, $Res Function(_$_Flying) _then)
      : super(_value, (v) => _then(v as _$_Flying));

  @override
  _$_Flying get _value => super._value as _$_Flying;
}

/// @nodoc
@JsonSerializable()
class _$_Flying extends _Flying {
  const _$_Flying({final String? $type})
      : $type = $type ?? 'flying',
        super._();

  factory _$_Flying.fromJson(Map<String, dynamic> json) =>
      _$$_FlyingFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Flying);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return flying();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return flying?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (flying != null) {
      return flying();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return flying(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return flying?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (flying != null) {
      return flying(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FlyingToJson(
      this,
    );
  }
}

abstract class _Flying extends PokemonTypes {
  const factory _Flying() = _$_Flying;
  const _Flying._() : super._();

  factory _Flying.fromJson(Map<String, dynamic> json) = _$_Flying.fromJson;
}

/// @nodoc
abstract class _$$_PsychicCopyWith<$Res> {
  factory _$$_PsychicCopyWith(
          _$_Psychic value, $Res Function(_$_Psychic) then) =
      __$$_PsychicCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PsychicCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_PsychicCopyWith<$Res> {
  __$$_PsychicCopyWithImpl(_$_Psychic _value, $Res Function(_$_Psychic) _then)
      : super(_value, (v) => _then(v as _$_Psychic));

  @override
  _$_Psychic get _value => super._value as _$_Psychic;
}

/// @nodoc
@JsonSerializable()
class _$_Psychic extends _Psychic {
  const _$_Psychic({final String? $type})
      : $type = $type ?? 'psychic',
        super._();

  factory _$_Psychic.fromJson(Map<String, dynamic> json) =>
      _$$_PsychicFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Psychic);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return psychic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return psychic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (psychic != null) {
      return psychic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return psychic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return psychic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (psychic != null) {
      return psychic(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_PsychicToJson(
      this,
    );
  }
}

abstract class _Psychic extends PokemonTypes {
  const factory _Psychic() = _$_Psychic;
  const _Psychic._() : super._();

  factory _Psychic.fromJson(Map<String, dynamic> json) = _$_Psychic.fromJson;
}

/// @nodoc
abstract class _$$_BugCopyWith<$Res> {
  factory _$$_BugCopyWith(_$_Bug value, $Res Function(_$_Bug) then) =
      __$$_BugCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_BugCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_BugCopyWith<$Res> {
  __$$_BugCopyWithImpl(_$_Bug _value, $Res Function(_$_Bug) _then)
      : super(_value, (v) => _then(v as _$_Bug));

  @override
  _$_Bug get _value => super._value as _$_Bug;
}

/// @nodoc
@JsonSerializable()
class _$_Bug extends _Bug {
  const _$_Bug({final String? $type})
      : $type = $type ?? 'bug',
        super._();

  factory _$_Bug.fromJson(Map<String, dynamic> json) => _$$_BugFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Bug);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return bug();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return bug?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (bug != null) {
      return bug();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return bug(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return bug?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (bug != null) {
      return bug(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_BugToJson(
      this,
    );
  }
}

abstract class _Bug extends PokemonTypes {
  const factory _Bug() = _$_Bug;
  const _Bug._() : super._();

  factory _Bug.fromJson(Map<String, dynamic> json) = _$_Bug.fromJson;
}

/// @nodoc
abstract class _$$_RockCopyWith<$Res> {
  factory _$$_RockCopyWith(_$_Rock value, $Res Function(_$_Rock) then) =
      __$$_RockCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_RockCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_RockCopyWith<$Res> {
  __$$_RockCopyWithImpl(_$_Rock _value, $Res Function(_$_Rock) _then)
      : super(_value, (v) => _then(v as _$_Rock));

  @override
  _$_Rock get _value => super._value as _$_Rock;
}

/// @nodoc
@JsonSerializable()
class _$_Rock extends _Rock {
  const _$_Rock({final String? $type})
      : $type = $type ?? 'rock',
        super._();

  factory _$_Rock.fromJson(Map<String, dynamic> json) => _$$_RockFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Rock);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return rock();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return rock?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (rock != null) {
      return rock();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return rock(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return rock?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (rock != null) {
      return rock(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_RockToJson(
      this,
    );
  }
}

abstract class _Rock extends PokemonTypes {
  const factory _Rock() = _$_Rock;
  const _Rock._() : super._();

  factory _Rock.fromJson(Map<String, dynamic> json) = _$_Rock.fromJson;
}

/// @nodoc
abstract class _$$_GhostCopyWith<$Res> {
  factory _$$_GhostCopyWith(_$_Ghost value, $Res Function(_$_Ghost) then) =
      __$$_GhostCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GhostCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_GhostCopyWith<$Res> {
  __$$_GhostCopyWithImpl(_$_Ghost _value, $Res Function(_$_Ghost) _then)
      : super(_value, (v) => _then(v as _$_Ghost));

  @override
  _$_Ghost get _value => super._value as _$_Ghost;
}

/// @nodoc
@JsonSerializable()
class _$_Ghost extends _Ghost {
  const _$_Ghost({final String? $type})
      : $type = $type ?? 'ghost',
        super._();

  factory _$_Ghost.fromJson(Map<String, dynamic> json) =>
      _$$_GhostFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Ghost);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return ghost();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return ghost?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (ghost != null) {
      return ghost();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return ghost(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return ghost?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (ghost != null) {
      return ghost(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_GhostToJson(
      this,
    );
  }
}

abstract class _Ghost extends PokemonTypes {
  const factory _Ghost() = _$_Ghost;
  const _Ghost._() : super._();

  factory _Ghost.fromJson(Map<String, dynamic> json) = _$_Ghost.fromJson;
}

/// @nodoc
abstract class _$$_DarkCopyWith<$Res> {
  factory _$$_DarkCopyWith(_$_Dark value, $Res Function(_$_Dark) then) =
      __$$_DarkCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_DarkCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_DarkCopyWith<$Res> {
  __$$_DarkCopyWithImpl(_$_Dark _value, $Res Function(_$_Dark) _then)
      : super(_value, (v) => _then(v as _$_Dark));

  @override
  _$_Dark get _value => super._value as _$_Dark;
}

/// @nodoc
@JsonSerializable()
class _$_Dark extends _Dark {
  const _$_Dark({final String? $type})
      : $type = $type ?? 'dark',
        super._();

  factory _$_Dark.fromJson(Map<String, dynamic> json) => _$$_DarkFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Dark);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return dark();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return dark?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (dark != null) {
      return dark();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return dark(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return dark?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (dark != null) {
      return dark(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_DarkToJson(
      this,
    );
  }
}

abstract class _Dark extends PokemonTypes {
  const factory _Dark() = _$_Dark;
  const _Dark._() : super._();

  factory _Dark.fromJson(Map<String, dynamic> json) = _$_Dark.fromJson;
}

/// @nodoc
abstract class _$$_DragonCopyWith<$Res> {
  factory _$$_DragonCopyWith(_$_Dragon value, $Res Function(_$_Dragon) then) =
      __$$_DragonCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_DragonCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_DragonCopyWith<$Res> {
  __$$_DragonCopyWithImpl(_$_Dragon _value, $Res Function(_$_Dragon) _then)
      : super(_value, (v) => _then(v as _$_Dragon));

  @override
  _$_Dragon get _value => super._value as _$_Dragon;
}

/// @nodoc
@JsonSerializable()
class _$_Dragon extends _Dragon {
  const _$_Dragon({final String? $type})
      : $type = $type ?? 'dragon',
        super._();

  factory _$_Dragon.fromJson(Map<String, dynamic> json) =>
      _$$_DragonFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Dragon);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return dragon();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return dragon?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (dragon != null) {
      return dragon();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return dragon(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return dragon?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (dragon != null) {
      return dragon(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_DragonToJson(
      this,
    );
  }
}

abstract class _Dragon extends PokemonTypes {
  const factory _Dragon() = _$_Dragon;
  const _Dragon._() : super._();

  factory _Dragon.fromJson(Map<String, dynamic> json) = _$_Dragon.fromJson;
}

/// @nodoc
abstract class _$$_SteelCopyWith<$Res> {
  factory _$$_SteelCopyWith(_$_Steel value, $Res Function(_$_Steel) then) =
      __$$_SteelCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SteelCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_SteelCopyWith<$Res> {
  __$$_SteelCopyWithImpl(_$_Steel _value, $Res Function(_$_Steel) _then)
      : super(_value, (v) => _then(v as _$_Steel));

  @override
  _$_Steel get _value => super._value as _$_Steel;
}

/// @nodoc
@JsonSerializable()
class _$_Steel extends _Steel {
  const _$_Steel({final String? $type})
      : $type = $type ?? 'steel',
        super._();

  factory _$_Steel.fromJson(Map<String, dynamic> json) =>
      _$$_SteelFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Steel);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return steel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return steel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (steel != null) {
      return steel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return steel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return steel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (steel != null) {
      return steel(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SteelToJson(
      this,
    );
  }
}

abstract class _Steel extends PokemonTypes {
  const factory _Steel() = _$_Steel;
  const _Steel._() : super._();

  factory _Steel.fromJson(Map<String, dynamic> json) = _$_Steel.fromJson;
}

/// @nodoc
abstract class _$$_FairyCopyWith<$Res> {
  factory _$$_FairyCopyWith(_$_Fairy value, $Res Function(_$_Fairy) then) =
      __$$_FairyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FairyCopyWithImpl<$Res> extends _$PokemonTypesCopyWithImpl<$Res>
    implements _$$_FairyCopyWith<$Res> {
  __$$_FairyCopyWithImpl(_$_Fairy _value, $Res Function(_$_Fairy) _then)
      : super(_value, (v) => _then(v as _$_Fairy));

  @override
  _$_Fairy get _value => super._value as _$_Fairy;
}

/// @nodoc
@JsonSerializable()
class _$_Fairy extends _Fairy {
  const _$_Fairy({final String? $type})
      : $type = $type ?? 'fairy',
        super._();

  factory _$_Fairy.fromJson(Map<String, dynamic> json) =>
      _$$_FairyFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Fairy);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() fire,
    required TResult Function() water,
    required TResult Function() grass,
    required TResult Function() electric,
    required TResult Function() ice,
    required TResult Function() fighting,
    required TResult Function() poison,
    required TResult Function() ground,
    required TResult Function() flying,
    required TResult Function() psychic,
    required TResult Function() bug,
    required TResult Function() rock,
    required TResult Function() ghost,
    required TResult Function() dark,
    required TResult Function() dragon,
    required TResult Function() steel,
    required TResult Function() fairy,
  }) {
    return fairy();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
  }) {
    return fairy?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? fire,
    TResult Function()? water,
    TResult Function()? grass,
    TResult Function()? electric,
    TResult Function()? ice,
    TResult Function()? fighting,
    TResult Function()? poison,
    TResult Function()? ground,
    TResult Function()? flying,
    TResult Function()? psychic,
    TResult Function()? bug,
    TResult Function()? rock,
    TResult Function()? ghost,
    TResult Function()? dark,
    TResult Function()? dragon,
    TResult Function()? steel,
    TResult Function()? fairy,
    required TResult orElse(),
  }) {
    if (fairy != null) {
      return fairy();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Normal value) normal,
    required TResult Function(_Fire value) fire,
    required TResult Function(_Water value) water,
    required TResult Function(_Grass value) grass,
    required TResult Function(_Electric value) electric,
    required TResult Function(_Ice value) ice,
    required TResult Function(_Fighting value) fighting,
    required TResult Function(_Poison value) poison,
    required TResult Function(_Ground value) ground,
    required TResult Function(_Flying value) flying,
    required TResult Function(_Psychic value) psychic,
    required TResult Function(_Bug value) bug,
    required TResult Function(_Rock value) rock,
    required TResult Function(_Ghost value) ghost,
    required TResult Function(_Dark value) dark,
    required TResult Function(_Dragon value) dragon,
    required TResult Function(_Steel value) steel,
    required TResult Function(_Fairy value) fairy,
  }) {
    return fairy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
  }) {
    return fairy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Normal value)? normal,
    TResult Function(_Fire value)? fire,
    TResult Function(_Water value)? water,
    TResult Function(_Grass value)? grass,
    TResult Function(_Electric value)? electric,
    TResult Function(_Ice value)? ice,
    TResult Function(_Fighting value)? fighting,
    TResult Function(_Poison value)? poison,
    TResult Function(_Ground value)? ground,
    TResult Function(_Flying value)? flying,
    TResult Function(_Psychic value)? psychic,
    TResult Function(_Bug value)? bug,
    TResult Function(_Rock value)? rock,
    TResult Function(_Ghost value)? ghost,
    TResult Function(_Dark value)? dark,
    TResult Function(_Dragon value)? dragon,
    TResult Function(_Steel value)? steel,
    TResult Function(_Fairy value)? fairy,
    required TResult orElse(),
  }) {
    if (fairy != null) {
      return fairy(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FairyToJson(
      this,
    );
  }
}

abstract class _Fairy extends PokemonTypes {
  const factory _Fairy() = _$_Fairy;
  const _Fairy._() : super._();

  factory _Fairy.fromJson(Map<String, dynamic> json) = _$_Fairy.fromJson;
}
